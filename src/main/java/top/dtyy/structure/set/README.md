## Set的实现
Set可用于单词数统计
###  BST实现
### 链表实现
## BSTSet和LinkedListSet性能比较
### 运行结果
```$xslt
Total words: 125901
Total diff words: 6530
BSTSet time costs : 0.095652683s
Total words: 125901
Total diff words: 6530
LinkedListSet time costs : 2.164017236s
```
### 复杂度分析
操作 | LinkedListSet | BSTSet | 平均 | 最差
---|---|---|---|---
新增 add | 0(n) | 0(h) | 0(log n) | 0(n)
查询 contains | 0(n) | 0(h) | 0(log n) | 0(n)
删除 remove | 0(n) | 0(h) | 0(log n) | 0(n)

注：0(n)和0(log n)之间是指数级别差距，性能相差很大。

链表实现中新增操作为保证数据唯一，做了一次查询操作。

h为树高度，BST准确复杂度是0(h)。完全二分搜索树中，树高h（0~h-1）和节点数n的关系是2^h - 1 = n，因此在该情况下时间复杂度是log2n。大多情况下，BST能够满足log n时间复杂度。

当二分搜索树退化成链表（例如，1 2 3 4 ...每个节点仅有一个分支)时，二分搜索树退化成链表，时间复杂度变成0(n).

## 有序集合和无序集合
有序集合中的元素具有顺序性，基于搜索树实现。因为有序，可以实现更强大的功能，例如很快地找到最大最小元素、某个元素的前置元素后置元素、第k个元素。

无序集合中的元素没有顺序性，基于哈希表的实现。链表实现也是无序的，但性能很差。哈希表无序集合实现在时间复杂度上略优于搜索树的有序集合实现。