## 数组
### 1. 数组基础
数据码成一排存放，每个元素都有索引，从0~n-1开始。

JDK数组
```java
int[] arr = new int[10];
arr.length
```
### 2. 自定义数组
注意：数组中存在空闲容量空间，假设数组容量为10，元素数为5，索引5到9空间即为空闲空间，对于用户是不可见的。

### 3. 泛型的使用
可以使数据结构放置任何数据类型；

【注1】不可以使用基本数据类型，只能是类对象，采用其对应的包装类。

【注2】不可以创建泛型数组，如 new E[capacity]。\
创建为 (E[]) new Object[capacity];

【注3】改用泛型后，对象类型的比较需要用equals，代替==。

【注4】使用泛型后，数组中存放的是类对象的引用。在逻辑删除某个元素后，data[size]还存放着该逻辑删除对象的引用，此时对象是loitering objects，闲置的对象，没有用但是不会被垃圾回收掉的对象（并不等于内存泄漏 memory leak）。
处理方法是，将该引用设为null，不再与对象关联，便于垃圾回收。 \
```java
data[size] = null;
```

### 4.动态数组
数组扩容，减容

### 5.时间复杂度分析
O(1), O(logn), O(n), O(nlogn), O(n^2), O(n^3) \
大O标记法描述的是算法的运行时间和输入数据n之间的关系。\
O(1)表示运行时间和输入数据无关。\
O(n)表示运行时间和输入数据成线性关系。\

实际时间 T= c1 * n + c2，通常忽略掉常数c1和c2。\
渐进时间复杂度：描述n趋近于无穷的情况。\

#### 添加-->O(n)
addLast(e):O(1)
addFirst(e):O(n)
add(index, e):O(n/2)=O(n)
算法复杂度通常关注的是最坏的情况。

#### 删除-->O(n)

#### 修改-->已知索引O(1)；未知索引O(n)

#### 查询-->已知索引O(1)；未知索引O(n)

### 6.扩容的复杂度分析
resize-->O(n) \
均摊复杂度分析\
假设数组容量为8，可以进行8次O(1)的addLast操作，第9次时，需要扩容，需要8+1次操作。添加9个元素需要17次操作，平均到每次约2次，仍属于O(1)。
均摊复杂度分析，主要是由于最坏的情况不是每次都触发的。

【注1】复杂度震荡\
数组元素个数size，容量为n。当size=n+1时，扩容数组容量为2n；当size=n时，又会缩容数组容量为n。不断触发resize操作。
出现问题的原因：缩容过于着急。\
解决方案：lazy策略\
当size == capacity / 4时，才将capacity减半。

【注2】扩容时，数组的容量不能为0，需要判断条件。\
data.length / 2 != 0

## JDK中对应ArrayList